name: AWO Run (CRI Orchestration v2)

on:
  workflow_dispatch:
    inputs:
      workflow_file:
        description: "Path to CRI workflow JSON"
        required: true
        default: "cri/multimodel.json"

permissions:
  contents: write
  id-token: write

jobs:
  run_awo:
    name: Execute CRI Workflow
    runs-on: ubuntu-latest
    outputs:
      run_id: ${{ steps.capture.outputs.run_id }}
      run_hash: ${{ steps.capture.outputs.run_hash }}
    steps:
      # ---------------------------------------------------------
      # 0. Checkout repository
      # ---------------------------------------------------------
      - name: Checkout
        uses: actions/checkout@v4

      # ---------------------------------------------------------
      # 1. Capture Workflow Path and Generate RUN_ID + RUN_HASH
      # ---------------------------------------------------------
      - name: Capture run identity
        id: capture
        shell: bash
        run: |
          set -euo pipefail
          WF_PATH="${{ github.event.inputs.workflow_file }}"
          echo "WF_PATH=$WF_PATH" >> $GITHUB_ENV
          
          # RUN_ID: stable, reproducible timestamp
          RUN_ID="run_$(date -u +%Y-%m-%dT%H-%M-%SZ)"
          echo "RUN_ID=$RUN_ID" >> $GITHUB_ENV
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          
          # RUN_HASH: cryptographic identity binding
          RUN_HASH=$(sha256sum "$WF_PATH" | awk '{print $1}')
          echo "RUN_HASH=$RUN_HASH" >> $GITHUB_ENV
          echo "run_hash=$RUN_HASH" >> $GITHUB_OUTPUT
          
          echo "Captured RUN_ID=$RUN_ID"
          echo "Captured RUN_HASH=$RUN_HASH"

      # ---------------------------------------------------------
      # 2. Validate workflow JSON against cri_workflow.schema.json
      # ---------------------------------------------------------
      - name: Validate CRI workflow JSON
        shell: bash
        run: |
          set -euo pipefail
          WF="$WF_PATH"
          SCHEMA="schemas/cri_workflow.schema.json"
          echo "Validating workflow JSON: $WF"
          echo "Using schema: $SCHEMA"
          
          python3 << 'PY'
          import json, sys, os
          from jsonschema import Draft202012Validator as V
          
          wf_path = os.environ["WF_PATH"]
          schema_path = "schemas/cri_workflow.schema.json"
          
          with open(wf_path, "r") as f:
              doc = json.load(f)
          with open(schema_path, "r") as f:
              schema = json.load(f)
          
          validator = V(schema)
          errors = sorted(validator.iter_errors(doc), key=lambda e: e.path)
          
          if errors:
              print("\nCRI workflow validation failed:\n")
              for e in errors:
                  print(f"- {e.message} (path: {'/'.join(map(str,e.path))})")
              sys.exit(1)
          
          print("CRI workflow schema validation OK")
          PY

      # ---------------------------------------------------------
      # 3. Ensure run directory exists
      # ---------------------------------------------------------
      - name: Create run directory
        shell: bash
        run: |
          mkdir -p "runs/${RUN_ID}"
          echo "Created run directory runs/${RUN_ID}"

      # ---------------------------------------------------------
      # 4. Run CRI operator DAG (scripts/awo_run.py)
      # ---------------------------------------------------------
      - name: Execute CRI DAG
        shell: bash
        run: |
          set -euo pipefail
          python scripts/awo_run.py "${WF_PATH}" "runs/${RUN_ID}"

      # ---------------------------------------------------------
      # 5. Create falsifiability.json (initial placeholder)
      # ---------------------------------------------------------
      - name: Create falsifiability placeholder
        shell: bash
        run: |
          set -euo pipefail
          TARGET="runs/${RUN_ID}/falsifiability.json"
          
          if [ ! -f "$TARGET" ]; then
            python3 -c "import json; print(json.dumps({
              'run_id': '${RUN_ID}',
              'run_hash': '${RUN_HASH}',
              'criteria': [
                'CRI workflow validated',
                'run_manifest.json exists',
                'operator graph executed'
              ],
              'status': 'not_evaluated',
              'evaluated_at': None,
              'notes': 'Awaiting reviewer or orchestrator evaluation.'
            }, indent=2))" > "$TARGET"
            echo "Created placeholder falsifiability.json"
          else
            echo "falsifiability.json already exists; skipping"
          fi

      # ---------------------------------------------------------
      # 6. Capture randomness metadata
      # ---------------------------------------------------------
      - name: Persist randomness metadata
        shell: bash
        run: |
          set -euo pipefail
          TARGET="runs/${RUN_ID}/randomness.json"
          
          # No seed provided by CRI yet, so just mark nondeterministic
          python3 -c "import json; print(json.dumps({
            'run_id': '${RUN_ID}',
            'seed': None,
            'deterministic': False
          }, indent=2))" > "$TARGET"
          echo "Persisted randomness metadata"

      # ---------------------------------------------------------
      # 7. Generate SHA256SUMS & SBOM
      # ---------------------------------------------------------
      - name: Generate provenance artifacts
        shell: bash
        run: |
          set -euo pipefail
          cd runs/${RUN_ID}
          sha256sum * > SHA256SUMS.txt
          
          # SBOM: minimal CycloneDX JSON listing
          TIMESTAMP="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          python3 -c "import json; print(json.dumps({
            'bomFormat': 'CycloneDX',
            'specVersion': '1.4',
            'version': 1,
            'metadata': {
              'timestamp': '${TIMESTAMP}',
              'tools': [{'name': 'AWO Runner', 'version': '2.0'}]
            },
            'components': []
          }, indent=2))" > sbom-cyclonedx.json
          
          echo "Generated SBOM and SHA256SUMS"

      # ---------------------------------------------------------
      # 8. Upload artifacts for review (scope gate)
      # ---------------------------------------------------------
      - name: Upload run artifacts
        uses: actions/upload-artifact@v4
        with:
          name: awo-run-${{ env.RUN_ID }}
          path: runs/${{ env.RUN_ID }}

  # =============================================================
  # HUMAN APPROVAL & ATTESTATION JOB
  # =============================================================
  human_approval:
    needs: run_awo
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Await human approval
        uses: trstringer/manual-approval@v1
        with:
          approvers: Wright-Shawn
          minimum-approvals: 1

      # ---------------------------------------------------------
      # 10. Commit ATTESTATION + update run_manifest.json
      # ---------------------------------------------------------
      - name: Commit attestation
        shell: bash
        run: |
          set -euo pipefail
          RUN_ID="${{ needs.run_awo.outputs.run_id }}"
          TIMESTAMP="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          
          mkdir -p ".tmp_attest/${RUN_ID}"
          
          python3 -c "import json; print(json.dumps({
            'run_id': '${RUN_ID}',
            'approved_by': 'Wright-Shawn',
            'timestamp': '${TIMESTAMP}',
            'notes': 'Human-approved run'
          }, indent=2))" > ".tmp_attest/${RUN_ID}/ATTESTATION.json"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          mkdir -p "runs/${RUN_ID}/"
          cp ".tmp_attest/${RUN_ID}/ATTESTATION.json" "runs/${RUN_ID}/ATTESTATION.json"
          
          git add "runs/${RUN_ID}/ATTESTATION.json"
          git commit -m "AWO: add attestation for ${RUN_ID}"
          git push
